<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>population</title>
  <Style>
      * {
  margin: 0;
  padding: 0;
}
/* #chart-container {
  position: relative;
  height: 100vh;
  overflow: hidden;
} */
#contents { 
  position: absolute;
  top: 0;
  bottom: 0;
  width: 100%;
 
}
#map1 { 
  position: absolute;
   top: 0;
    bottom: 0;
     width: 49.9%;
}
#map2 { 
  position: absolute;
   top: 0;
   left : 50.1%;
    bottom: 0;
     width: 49.9%;
}
/* #map3 { 
  position: absolute;
   top: 0;
   left : 66%;
    bottom: 0;
     width: 33%;
} */
#plot1 { 
  position: absolute;
  top: 0;
  bottom: 0;
}
#plot2 { 
  position: absolute;
  top: 0;
  bottom: 0;
}
/* #plot3 { 
  position: absolute;
  top: 0;
  bottom: 0;
} */
#tooltip1 { 
  position: absolute;
   top: 0;
    bottom: 0;
     width: 49.9%;
     height: 100%;
}
#tooltip2 { 
  position: absolute;
   top: 0;
    left : 50.1%;
    bottom: 0;
     width: 49.9%;
     height: 100%;
}
/* #tooltip3 { 
  position: absolute;
   top: 0;
    left : 66%;
    bottom: 0;
     width: 33%;
     height: 100%;
} */
svg {
    position: absolute;
    overflow : hidden;
    z-index : 10;
}

#chechBox {
  position: absolute;
   width : 100%;
   bottom : 90px;
   /* left : 45%; */
   font-family : "Arial Black";
   font-size : 20px;
   color : white;
   text-align: center;
   /* left : 20%; */
   /* background-color: rgba(0,0,0,0.8);
   border-radius: 10px 10px;
   padding : 6px 0px 11px 0px; */
}

#bottomBar {
  position: absolute;
   width : 100%;
   height : 150px;
   bottom : 0px;
   /* left : 45%; */   
   background-color: rgba(0,0,0,0.8);

}



.range-slider {
    position: absolute;
    width : 90%;
    height: 80px;
    bottom : 10px;
    left : 5%;
    align-content: center;
   
}

  </Style>

<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<link href="./mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v2.9.1/mapbox-gl.js"></script>
<script type="text/javascript" src="./papaparse.min.js"></script>
<script src="./d3.v7.min.js"></script>
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-scale@4"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-tricontour@1"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-array@3"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-geo@3"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-dispatch@3"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-ease@3"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-selection@3"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-timer@3"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-transition@3"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-drag@3"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-zoom@3"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/d3-contour@4"></script> -->
<script src="./proj4-src.js"></script>
<script src="./turf.min.js"></script>
<!--Plugin CSS file with desired skin-->
<link rel="stylesheet" href="./ion.rangeSlider.min.css"/>
<!--jQuery-->
<script src="./jquery.min.js"></script>
<!--Plugin JavaScript file-->
<script src="./ion.rangeSlider.min.js"></script>
<script src='./mapbox-gl-language.js'></script>
<link href="./icheck/skins/square/blue.css" rel="stylesheet">
<script src="./icheck/icheck.min.js"></script>
</head>
<body>
  <div id = "contents" ></div>
  <div id = "map1" ></div>
  <div id = "map2" ></div>
  <div id = "map3" ></div>
  <div id = "bottomBar">
    <div class="range-slider">
      <input type="text" id="staySlider" name="timeThreshold" value="" />
    </div>
    <div id = "chechBox">    
      <label for="syncMap"> 
        <input id = "syncMap" type="checkbox" checked> Sync. Maps
      </label>
      <br/>
      <label for="dynamicBubble"> 
        <input id = "dynamicBubble" type="checkbox" checked> Dynamic Bubble
      </label>
    </div>
  </div>

<script >

 
  class Mapset {

    constructor (data, map, canvasID, tooltipID) {
      this.data = data;
      this.map = map;
      this.canvasID = canvasID;
      this.tooltipID = tooltipID;
      this.compMapset = [];

      this.currentZoom = 0;
      this.unit = 1;

      this.dataMap = new Map();
      this.features;
      this.maxValue = 0;
      this.minValue = 0;
      
    }

    updateSliderData() {

      sliderInstance.update({
        //to : sliderInstance.options.max==sliderInstance.options.to? Math.log(maxValue) : sliderInstance.options.to,
        max: (() => { 
          let maxValue = 0;
          mapsetArr.forEach( (mapset)=> {
            maxValue = d3.max([maxValue, mapset.maxValue]);
          });          
          return Math.log(maxValue);
        })(),    
        to: (() => { 
          let maxValue = 0;
          mapsetArr.forEach( (mapset)=> {
            maxValue = d3.max([maxValue, mapset.maxValue]);
          });          
          return Math.log(maxValue);
        })(),    
      });
      showMin = sliderInstance.options.from;
      showMax = sliderInstance.options.to;
      //console.log("updateSlider : "+showMin+","+showMax);
    }

    functionDraw() {

      d3.select("#contents")
                  .append("svg")
                  .attr("id", this.tooltipID)
                  .style("pointer-events", "none");
                  //.append("g");
      //let currentZoom;// = 0;// map.getZoom();    
      //let features;
      //let maxValue = 0;
      //let minValue = 0;


      //데이터 WGS84 변환
      this.features = this.data.features.map(({geometry, properties, type})=>{
        const [x,y] = proj4('EPSG:5179','EPSG:4326',geometry.coordinates);
        geometry = {
          coordinates : [x,y],
          type : geometry.type
        };
        return {x:x, y:y, value : properties.popu};
      });

      //canvas 셋팅
      const container = this.map.getCanvasContainer();

      const w0 = container.offsetWidth;
      const h0 = window.innerHeight;
      const canvas = d3.select(container)
          .append("canvas")
          .attr("id", this.canvasID)
          .attr("width", w0)
          .attr("height", h0);
          //.attr("z-index", 10);  
      
      //console.log("zoom : " + this.map.getZoom());
      this.checkZoomAndRenewData();

      this.map.on("viewreset", () => {
        if (syncMaps) {
          //console.log("viewreset!!!!!!!!!!!!!!!!!!!!!!!!!");
          if (!preventAdditionalEvent) {
            const center = this.map.getCenter();
            const zoom = this.map.getZoom();
            const pitch = this.map.getPitch();
            const bearing = this.map.getBearing();

            preventAdditionalEvent = true;
            this.compMapset.forEach( (mapset)=> {
              //console.log(map);
              mapset.map.setCenter(center);
              mapset.map.setZoom(zoom);
              mapset.map.setPitch(pitch);
              mapset.map.setBearing(bearing);
              mapset.render();
            });
            preventAdditionalEvent = false;
            //console.log("sync");
          }
        }
        
        this.render();
        
      });
      this.map.on("move", (e) => {
        if (syncMaps) {
          //console.log("move!!!!!!!!!!!!!!!!!!!!!!!!!");
          if (!preventAdditionalEvent) {
            const center = this.map.getCenter();
            const zoom = this.map.getZoom();
            const pitch = this.map.getPitch();
            const bearing = this.map.getBearing();

            preventAdditionalEvent = true;
            this.compMapset.forEach( (mapset)=> {
              //console.log(map);
              mapset.map.setCenter(center);
              mapset.map.setZoom(zoom);
              mapset.map.setPitch(pitch);
              mapset.map.setBearing(bearing);
              mapset.render();
            });
            preventAdditionalEvent = false;
            //console.log("sync");
          }
        }
        
        this.render();
        const tooltip = d3.select("#"+this.tooltipID);  
        //
        tooltip.selectAll(".tooltipTxt").remove();
        //tooltip.selectAll("text").remove();         
        
      });
      // this.map.on("moveend",() => {
      //   if (syncMaps) {
      //     console.log("moveEnd!!!!!!!!!!!!!!!!!!!!!!!!!");
      //     if (!preventAdditionalEvent) {
      //       const center = this.map.getCenter();
      //       const zoom = this.map.getZoom();
      //       const pitch = this.map.getPitch();
      //       const bearing = this.map.getBearing();

      //       preventAdditionalEvent = true;
      //       this.compMapset.forEach( (mapset)=> {
      //         //console.log(map);
      //         mapset.map.setCenter(center);
      //         mapset.map.setZoom(zoom);
      //         mapset.map.setPitch(pitch);
      //         mapset.map.setBearing(bearing);
      //         mapset.render();
      //       });
      //       preventAdditionalEvent = false;
      //       //console.log("sync");
      //     }
      //   }
        
      //   this.render();
        
      // });
      
      this.map.on('click', (e) => {
        const unit = this.unit;
        const [x1,y1] = proj4('EPSG:4326','EPSG:5179', [e.lngLat.lng, e.lngLat.lat]);
        const key = parseInt(x1/unit) * 10000 +
                            parseInt(y1/unit);

        if (this.dataMap.has(key)) {
          const value = this.dataMap.get(key); 
          if (Math.log(value) >= showMin && Math.log(value)<= showMax) {
            showMin = Math.log(value);//data.from;
            sliderInstance.update({
              from : showMin            
            });
            mapsetArr.forEach(mapset=>mapset.render()); 
          }
          //console.log("click!");
        }
      });


      

      this.map.on('mousemove', (e) => {
        this.showTooltip(e);
        this.compMapset.forEach(map=>map.showTooltip(e)); 
        //console.log(mousePos);
      });

      this.updateSliderData();
      this.render();


    }

    showTooltip(e) {
        const unit = this.unit;
        // `e.point` is the x, y coordinates of the `mousemove` event
        // relative to the top-left corner of the map.
       // console.log(e.point);
        
        const [x1,y1] = proj4('EPSG:4326','EPSG:5179', [e.lngLat.lng, e.lngLat.lat]);
        
        const key = parseInt(x1/unit) * 10000 +
                          parseInt(y1/unit);
        
        const tooltip = d3.select("#"+this.tooltipID);  
        //
        tooltip.selectAll(".tooltipTxt").remove();
           

        if (this.dataMap.has(key)) {
          //console.log([x1,y1]);
          const value = this.dataMap.get(key); 
          if (Math.log(value) >= showMin && Math.log(value)<= showMax) {

            //그리드 사각박스 그리기 좌표
            const mouse5179 = {x : x1, y : y1,
                          swx : parseInt(x1/unit)*unit, swy : parseInt(y1/unit)*unit,
                          nex : parseInt(x1/unit)*unit + unit, ney : parseInt(y1/unit)*unit + unit};
            const [swLat, swLng] = proj4('EPSG:5179','EPSG:4326', [mouse5179.swx, mouse5179.swy]);
            const [neLat, neLng] = proj4('EPSG:5179','EPSG:4326', [mouse5179.nex, mouse5179.ney]);

            const swP = this.map.project(new mapboxgl.LngLat(swLat, swLng));
            const neP = this.map.project(new mapboxgl.LngLat(neLat, neLng));
            //console.log(value);
            //const [x,y] = [e.point.x, e.point.y];
                      
            tooltip.append("rect")
                    .attr("class", "tooltipTxt")
                    .attr("x", swP.x)
                    .attr("y", neP.y)
                    .attr("width", neP.x-swP.x)
                    .attr("height", swP.y-neP.y)
                    .attr('stroke', 'black')
                    .attr('fill','black')
                    .attr('opacity', 0.5);

            tooltip.append("rect")
                    .attr("class", "tooltipTxt")
                    .attr("x", (swP.x+neP.x)/2-50)
                    .attr("y", neP.y-40)
                    .attr("width", 100)
                    .attr("height", 20)
                    .attr('stroke', 'black')
                    .attr('fill','black')
                    .attr('opacity', 0.8);              
            
            tooltip.append("text")
                    .attr("class", "tooltipTxt")
                    .attr("id","tooltipText")
                    .attr("x", (swP.x+neP.x)/2)
                    .attr("y",  neP.y-20)
                    .attr("text-anchor","middle")
                    .attr("alignment-baseline","alphabetic")
                    .style("font-family", "Arial Black")
                    .style("font-size", "20px")
                    .style("fill", "white")
                    .text(value.toLocaleString('ko-KR', {maximumFractionDigits:0}));
            //const text = d3.select('#tooltip');
            //text.text(`here~~`);
          } 
          
        }


        
      };

    render() {
      
      this.checkZoomAndRenewData();      

      //버퍼를 포함한 화면 범위 측정 for frustum culling
      const {_sw, _ne} = this.map.getBounds();
      _sw.lng -= 0.01;
      _sw.lat -= 0.01;
      _ne.lng += 0.01;
      _ne.lat += 0.01;
      //console.log(_sw);




      let timeStart, timeEnd;
      timeStart = new Date();  // 시작

      const sizeLimit = 200;
      const colorLimit = this.maxValue*0.1;
      const mapColor = d3.scaleSequential(d3.interpolateYlGnBu).domain([ Math.log(colorLimit), Math.log(this.maxValue)]);

      const canvas0 = document.getElementById(this.canvasID);
      const context = canvas0.getContext("2d");

      context.clearRect(0, 0, canvas0.width, canvas0.height);
      context.opacity = 1;
      context.lineWidth = 1.5;//d.value%10==0? 3 : 0.2;
      let count = 0 ;

      for (let d of this.features) {

        if (Math.log(d.value) < showMin || Math.log(d.value)> showMax) continue; 
        if (d.x<_sw.lng || d.y<_sw.lat || d.x>_ne.lng || d.y>_ne.lat) continue; //frustum culling
        
        //console.log(mousePos);

        
        // if (d.ox-unit/2<=mousePos.x && d.ox+unit/2>mousePos.x && d.oy-unit/2<=mousePos.y && d.oy+unit/2>mousePos.y) {
        //   console.log(d.value);
        // }  

        const color0 =  d3.color(mapColor(Math.log(d.value)));
        color0.opacity = 0.7;
        context.fillStyle = color0;
        context.strokeStyle = "white";//mapColor(d.value);

        const p = this.map.project(new mapboxgl.LngLat(d.x, d.y));
        //console.log(p);
        let radius;
        if (this.currentZoom >= 14) {          
          const r = d3.scaleLinear().domain([0,colorLimit, this.maxValue]).range([0,sizeLimit,3500])(d.value);
          radius = Math.pow(r, 0.5);
        } else {          
          const r = d3.scaleLinear().domain([0,colorLimit, this.maxValue]).range([0,sizeLimit*0.5,sizeLimit])(d.value);
          radius = Math.pow(r,0.5) *0.6;
        }
                                

        context.beginPath();     
        context.arc(p.x, p.y, radius, 0, 2 * Math.PI, false);        
        context.stroke();
        context.fill();
        count++;
      }
      timeEnd = new Date();  // 종료  
      //console.log("render : "+count+"points, " +(timeEnd-timeStart)+"ms");
    }

    renewFeatures(unit) {

      let timeStart, timeEnd;
      this.dataMap.clear();

      timeStart = new Date();  // 시작
      for (let i=0 ; i<this.data.features.length ; i++) {
        const {geometry, properties, type} =  this.data.features[i];
      
      //for ({geometry, properties, type} in this.data.features) {        
        const key = parseInt(geometry.coordinates[0]/unit) * 10000 +
                      parseInt(geometry.coordinates[1]/unit);
        let value = properties.popu;         
        if (this.dataMap.has(key)) {
          value += this.dataMap.get(key); 
        }
        this.dataMap.set(key, value);   
      }   

      //console.log("renew :" +(end-start)+"ms");

      this.features = new Array();
      this.maxValue = 0;
      this.minValue = 999999999999999;
      //console.log(this.dataMap);
  
      for (let [key, value] of this.dataMap) {
        const [ox, oy] =  [ parseInt(key/10000)*unit + unit/2, (key%10000)*unit + unit/2];
        const [x,y] = proj4('EPSG:5179','EPSG:4326', [ox, oy]);
        this.features.push({x:x, y:y, value:value, ox:ox, oy:oy});
        //업데이트
        if (value<this.minValue) this.minValue = value;
        if (value>this.maxValue) this.maxValue = value;
      }
      timeEnd = new Date();  // 종료  
      //console.log(Math.log(maxValue)+"/"+Math.log(minValue));
      //console.log("---------------renew :" +(timeEnd-timeStart)+"ms");
    }

    checkZoomAndRenewData() {

      if (!dynamicBubble) return;
      //console.log("checkzoom");
      const unitZoom = [1000000, 1000000, 500000, 250000, 100000, 50000, 25000, 10000, 5000, 2500, 1250, 750, 500, 250];
                        //0       1       2       3       4       5       6     7       8     9     10   11   12   13
      const zoomNow = parseInt(this.map.getZoom()+1.2);

      if (zoomNow != this.currentZoom) {        
        this.currentZoom = parseInt(zoomNow);
        this.unit = unitZoom[Math.min(13, this.currentZoom)];
        this.renewFeatures(this.unit);    
        this.updateSliderData();   
        //console.log(this.currentZoom);
      }

      
    }

    

    //파일 읽기
    static loadJson(fileName) {
      
      const file = loadFile(fileName);
      const results = Papa.parse(file, {
        //download: true,
        header : true,
        delimiter :'\t',
        dynamicTyping : true,
        skipEmptyLines: true,
        // complete: function(results) {
        //   //1. features로 변환  
        // }         
      });

      function loadFile(filePath) {
        let result = null;
        const xmlhttp = new XMLHttpRequest();
        xmlhttp.open("GET", filePath, false);
        xmlhttp.send();
        if (xmlhttp.status==200) {
          result = xmlhttp.responseText;
        }
        //console.log(result);
        return result;
      }

      const points = results.data.map((d) => {
            const [x,y] = [(d.x+BASE_UNIT/2), (d.y+BASE_UNIT/2)];
            return turf.point([x,y], {popu : d.value}); 
          });
      const pointsCollection = turf.featureCollection(points);

      const bound = {xmin : d3.min( pointsCollection.features.map(d=>d.geometry.coordinates[0])),
                      xmax : d3.max(  pointsCollection.features.map(d=>d.geometry.coordinates[0])),
                      ymin : d3.min(  pointsCollection.features.map(d=>d.geometry.coordinates[1])),
                      ymax : d3.max(  pointsCollection.features.map(d=>d.geometry.coordinates[1]))                        
                    };
      return pointsCollection;   
          
    }




  }


 
  let preventAdditionalEvent = false;
  const BASE_UNIT = 250;
  let showMin = 0;
  let showMax = 999999999;
  let syncMaps = true;
  let dynamicBubble = true;

  mapboxgl.accessToken = 'pk.eyJ1Ijoic2JraW00MjciLCJhIjoiY2o4b3Q0aXd1MDdyMjMzbnRxYTdvdDZrbCJ9.GCHi6-mDGEkd3F-knzSfRQ';
  //mapboxgl.setRTLTextPlugin('https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js');

  const map1 = createMap('map1');
  const map2 = createMap('map2');
  //const map3 = createMap('map3');
  initMap(map1);
  initMap(map2);
  //initMap(map3);

  function createMap(containerID) {
    return  new mapboxgl.Map({
      container: containerID, // container ID
      //style: 'mapbox://styles/mapbox/streets-v11', // style URL
      style: 'mapbox://styles/mapbox/dark-v10',
      center: [127.02754, 37.497], // starting position [lng, lat]
      zoom: 10, // starting zoom      
      //projection: 'globe' // display the map as a 3D globe
    });    
  }

  function initMap(map) {
    map.dragRotate.disable(); 
    map.touchZoomRotate.disableRotation();    
    map.addControl(new MapboxLanguage({
      defaultLanguage: 'ko'
    }));
    // map.on('style.load', () => {
    //     map.setFog({}); // Set the default atmosphere style
    // });
  }

  function range(start, end, gap) {
        return Array((end - start)/gap + 1).fill().map((_, idx) => start + (idx*gap));
  } 

  
  //console.log($rangeTime);
  const $rangeTime = $("#staySlider");
  $rangeTime.ionRangeSlider();
  const sliderInstance = $rangeTime.data("ionRangeSlider");




                  
  const data1 = Mapset.loadJson("./popu2000.tsv");
  const data2 = Mapset.loadJson("./popu2019.tsv");
  // const data3 = Mapset.loadJson("./11350_휴일_생활권.tsv");


  const mapset1 = new Mapset(data1, map1, 'plot1', 'tooltip1');
  const mapset2 = new Mapset(data2, map2, 'plot2', 'tooltip2');
  mapset1.title = "2000년";
  mapset2.title = "2019년";
  // const mapset3 = new Mapset(data3, map3, 'plot3', 'tooltip3');

  //const mapsetArr = [mapset1];
  const mapsetArr = [mapset1, mapset2];
  //const mapsetArr = [mapset1, mapset2, mapset3];

  //각각의 맵에 다른 맵 등록하기
  for (mapset of mapsetArr) {
    for (otherMapset of mapsetArr) {
      if (mapset != otherMapset) {
        mapset.compMapset.push(otherMapset);
        console.log(mapset);
      }
    }
  }



  //그리기 메인 함수 시작
  mapsetArr.forEach(mapset=>mapset.functionDraw());


  //제목달기
  mapsetArr.forEach( (mapset)=>{
    drawTitle(mapset);
  }); 

  function drawTitle(mapset){
    d3.select("#"+mapset.tooltipID).selectAll(".title").remove();
    const canvas0 = document.getElementById(mapset.canvasID);
    d3.select("#"+mapset.tooltipID)
                  .append("rect")
                  .attr("class", "title")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", canvas0.width)
                    .attr("height", 40)
                    //.attr('stroke', 'black')
                    .attr('fill','black')
                    .attr('opacity', 0.8);

    d3.select("#"+mapset.tooltipID)
                  .append("text")
                  .attr("class", "title")
                  .attr("x", canvas0.width/2)
                  .attr("y",  33)
                  .attr("text-anchor","middle")
                  //.attr("alignment-baseline","alphabetic")
                  .style("font-family", "Noto Sans CJK KR")
                  .style('font-weight', 'Bold')
                  .style("font-size", "30px")
                  .style("fill", "white")
                  .text(mapset.title);
  }


  //range slider 초기 셋팅
  sliderInstance.update({
        skin: "big",
        type: "double",
        //grid : true,
        min: 0,
        max: (() => {
          let maxValue = 0;
          //console.log("maxV :" +maxValue);
          mapsetArr.forEach( (mapset)=> {
            maxValue = d3.max([maxValue, mapset.maxValue]);
          });
          
          return Math.log(maxValue);
        })(),
        //values: valueGrid,
        from: 0,        
        step : 0.0001,
        //prettify_enabled: true,
        //prettify_separator: ",",
        prettify : (n) => {          
          return Math.pow(Math.exp(1),n).toLocaleString('ko-KR', {maximumFractionDigits: 0});
        },
        postfix: "명",
        onStart: (sliderData) => { 
          showMin = sliderData.from;
          showMax = sliderData.to;
          mapsetArr.forEach(d=>d.render()); 
        },
        onChange:  (sliderData) => { 
          showMin = sliderData.from;
          showMax = sliderData.to;
          mapsetArr.forEach(d=>d.render()); 
        }
   });


  //최대최소 업데이트 된 데이터로 다시 그리기 
  showMin = sliderInstance.options.from;
  showMax = sliderInstance.options.to;
  mapsetArr.forEach(mapset=>mapset.render()); 


  //체크박스 버튼
  $(document).ready(function(){
    $('#syncMap').iCheck({
      checkboxClass: 'icheckbox_square-blue',
      //radioClass: 'iradio_square-red',
      increaseArea: '20%' // optional
    });
  });    
  $('#syncMap').on('ifChecked', function(event){
    syncMaps = true;    
  });
  $('#syncMap').on('ifUnchecked', function(event){
    syncMaps = false;
  });


  $(document).ready(function(){
    $('#dynamicBubble').iCheck({
      checkboxClass: 'icheckbox_square-blue',
      //radioClass: 'iradio_square-red',
      increaseArea: '20%' // optional
    });
  });    
  $('#dynamicBubble').on('ifChecked', function(event){
    dynamicBubble = true;
    mapsetArr.forEach(d=>d.render()); 
  });
  $('#dynamicBubble').on('ifUnchecked', function(event){
    dynamicBubble = false;
  });


  window.addEventListener('resize', function() {
      const h = window.innerHeight;

      mapsetArr.forEach((mapset) => {

        const container = mapset.map.getCanvasContainer();

        const w0 = container.offsetWidth;
        d3.select("#"+mapset.canvasID)
          .attr("width", w0)
          .attr("height", h);  

        
      });    
      mapsetArr.forEach(d=>d.render());
      mapsetArr.forEach( (mapset)=>{
        drawTitle(mapset);
      }); 
  });


</script>
<script>


</script>

</body>
</html>